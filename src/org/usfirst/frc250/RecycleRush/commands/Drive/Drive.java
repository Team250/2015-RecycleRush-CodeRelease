// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc250.RecycleRush.commands.DriveFolder;

import edu.wpi.first.wpilibj.command.Command;

import org.usfirst.frc250.RecycleRush.Robot;
import org.usfirst.frc250.RecycleRush.RobotMap;
import org.usfirst.frc250.RecycleRush.Utilities;

/**
 *
 */
public class Drive extends Command {

	public Drive() {
		// Use requires() here to declare subsystem dependencies
		// eg. requires(chassis);
		requires(Robot.drivetrain);
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES

		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
	}

	// Called just before this Command runs the first time
	protected void initialize() {
	}

	// Called repeatedly when this Command is scheduled to run
	protected void execute() {
		int pov = Robot.oi.driver.getPOV();
		double orientationDelta = Utilities.angleDifference(
				Robot.drivetrain.getOrientation(),
				Robot.purpleSensor.getHeading());
		double trigger = Robot.oi.driver.getRawAxis(3)
				- Robot.oi.driver.getRawAxis(2);

		double vert = Robot.oi.driver.getRawAxis(4);
		double horiz = Robot.oi.driver.getRawAxis(5);
		double js2magnitude = Math.abs(Math.hypot(vert, horiz));

		if (pov != -1) {
			// Point-of-view hat for slower, more precise driving
			pov = -pov - 90;
			double forward = Math.sin(Math.toRadians(pov))
					* RobotMap.kDRIVE_POV_FACTOR;
			double strafe = Math.cos(Math.toRadians(pov))
					* RobotMap.kDRIVE_POV_FACTOR;
			if (Robot.drivetrain.isFieldOriented()) {
				Robot.drivetrain.fieldOrientedDrive(forward, strafe,
						Robot.purpleSensor.getHeading());
			} else {
				Robot.drivetrain.realMathDrive(forward
						* RobotMap.kDRIVE_ROBOT_ORIENTED_POV_MULTIPLIER, strafe
						* RobotMap.kDRIVE_ROBOT_ORIENTED_POV_MULTIPLIER, 0);
			}
		} else if (Robot.oi.driver.getMagnitude() > 0.2
				|| Math.abs(trigger) > 0.1 || Math.abs(orientationDelta) > 4) {
			// General driving
			if (Math.abs(trigger) > 0.1) {
				Robot.drivetrain.setOrientation(Robot.drivetrain
						.getOrientation()
						+ trigger
						* RobotMap.kDRIVE_TRIGGER_MULTIPLIER);
			}
			if (js2magnitude > 0.6) {
				// Robot.drivetrain.setOrientation(-Utilities.tangentAngle(vert,
				// horiz)); //Uncomment this line for right joystick FPS driving
			}
			double x = Math.abs(Robot.oi.driver.getX()) < 0.1 ? 0
					: Robot.oi.driver.getX();
			double y = Math.abs(Robot.oi.driver.getY()) < 0.1 ? 0
					: Robot.oi.driver.getY();

			if (Robot.drivetrain.isFieldOriented()) {
				Robot.drivetrain.fieldOrientedDrive(y, -x,
						Robot.purpleSensor.getHeading());
			} else {
				Robot.drivetrain.realMathDrive(y
						* RobotMap.kDRIVE_ROBOT_ORIENTED_MULTIPLIER, -x
						* RobotMap.kDRIVE_ROBOT_ORIENTED_MULTIPLIER, -trigger
						* RobotMap.kDRIVE_ROBOT_ORIENTED_MULTIPLIER);
			}
		} else {
			Robot.drivetrain.drive(0);
		}
	}

	// Make this return true when this Command no longer needs to run execute()
	protected boolean isFinished() {
		return false;
	}

	// Called once after isFinished returns true
	protected void end() {
	}

	// Called when another command which requires one or more of the same
	// subsystems is scheduled to run
	protected void interrupted() {
	}
}
