// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc250.RecycleRush.subsystems;

import org.usfirst.frc250.RecycleRush.RobotMap;
import org.usfirst.frc250.RecycleRush.commands.Elevator.ElevatorDrive;

import edu.wpi.first.wpilibj.DigitalInput;
import edu.wpi.first.wpilibj.DoubleSolenoid;
import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.SpeedController;
import edu.wpi.first.wpilibj.command.PIDSubsystem;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

/**
 *
 */
public class Elevator extends PIDSubsystem {
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    Encoder elevatorEncoder = RobotMap.elevatorElevatorEncoder;
    SpeedController elevatorMotor = RobotMap.elevatorElevatorMotor;
    DoubleSolenoid ratchet = RobotMap.elevatorRatchet;
    DigitalInput limitUp = RobotMap.elevatorLimitUp;
    DigitalInput limitDown = RobotMap.elevatorLimitDown;
    DigitalInput limitRatchet = RobotMap.elevatorLimitRatchet;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

	public enum RatchetDirectionEnum {
		UP, DOWN, INDETERMINATE
	}

	private int counter = 0;
	private boolean turbo = false;

	// Initialize your subsystem here
	public Elevator() {
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=PID
        super("Elevator", 1.0, 0.0, 0.0);
        setAbsoluteTolerance(0.2);
        getPIDController().setContinuous(false);
        LiveWindow.addActuator("Elevator", "PIDSubsystem Controller", getPIDController());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=PID

		setRatchetDirection(RatchetDirectionEnum.UP);
	}

	public void initDefaultCommand() {
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
        setDefaultCommand(new ElevatorDrive());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

		// Set the default command for a subsystem here.
		// setDefaultCommand(new MySpecialCommand());
	}

	// Sets the elevator target position using encoder pulses
	public void setElevatorTargetPosition(double position) {
		setSetpoint(position);
	}

	public void setElevatorRelativeTargetPosition(double positionDelta) {
		setSetpointRelative(positionDelta);
	}

	public double getElevatorCurrentPosition() {
		return elevatorEncoder.getDistance();
	}

	public double getElevatorTargetPosition() {
		return getSetpoint();
	}

	public RatchetDirectionEnum getRatchetDirection()
	{

		if (!limitRatchet.get()
				&& ratchet.get() == RobotMap.kELEVATOR_DIRECTION_UP) {
			return RatchetDirectionEnum.UP;
		} else if (limitRatchet.get()
				&& ratchet.get() == RobotMap.kELEVATOR_DIRECTION_DOWN) {
			return RatchetDirectionEnum.DOWN;
		} else {
			return RatchetDirectionEnum.INDETERMINATE;
		}
	}

	public boolean isLowerLimitReached() {
		return limitDown.get();
	}

	public boolean isUpperLimitReached() {
		return limitUp.get();
	}

	public void setSpeed(double speed) {
		speed = Math.max(speed, RobotMap.kELEVATOR_MAX_SPEED_DOWN);
		speed = Math.min(speed, RobotMap.kELEVATOR_MAX_SPEED_UP);

		if (getRatchetDirection() == RatchetDirectionEnum.UP && !limitUp.get()
				&& speed > 0) {
			// Going up
			if (getElevatorCurrentPosition() > 40) {
				// In the top speed zone
				elevatorMotor.set(speed
						* RobotMap.kELEVATOR_TOP_SPEED_ZONE_MULTIPLIER);
			} else {
				// Not in the top speed zone
				elevatorMotor.set(speed);
			}
		} else if (getRatchetDirection() == RatchetDirectionEnum.DOWN
				&& !limitDown.get() && speed < 0) {
			// Going down
			if (getElevatorCurrentPosition() < 5) {
				elevatorMotor.set(speed
						* RobotMap.kELEVATOR_BOTTOM_SPEED_ZONE_MULTIPLIER);
			} else {
				elevatorMotor.set(speed);
			}
		} else {
			// Some condition not met, stop driving
			elevatorMotor.set(0);
			if (limitDown.get() && getElevatorCurrentPosition() < 2) {
				resetEncoder();
			}
		}
	}

	public void slowCrash() {
		if (counter <= RobotMap.kELEVATOR_CONTROLLED_DESCENT_DUTY_CYCLE) {
			setSpeed(RobotMap.kELEVATOR_FREEFALL_DOWN_SPEED); // freefall
		} else {
			setSpeed(RobotMap.kELEVATOR_BRAKE_DOWN_SPEED); // break
			counter = 0;
		}
		counter++;
	}

	public void setPosition(double position) {
		setSetpoint(position);
	}

	public void setPIDControl(boolean x) {
		if (x) {
			// Set PID position to actual position before enabling PID to stop
			// it from moving
			setPosition(getElevatorCurrentPosition());
			enable();
		} else {
			disable();
		}
	}
	
	public void setTurboMode(boolean x) {
		turbo = x;
	}

	private void resetEncoder() {
		elevatorEncoder.reset();
	}

	public void setRatchetDirection(RatchetDirectionEnum direction) {
		if (elevatorMotor.get() != 0) {
			elevatorMotor.set(0);
			System.out
					.println("Stopping elevator to move ratchet. THIS SHOULDN'T HAPPEN");
		}
		if (direction == RatchetDirectionEnum.UP) {
			ratchet.set(DoubleSolenoid.Value.kForward);
		}
		if (direction == RatchetDirectionEnum.DOWN) {
			ratchet.set(DoubleSolenoid.Value.kReverse);
		}
	}

	public double findNextPosition(boolean up) {
		double currentPosition = getElevatorCurrentPosition();
		double candidate = up ? 9999 : -9999;
		double[] positions = RobotMap.kELEVATOR_POSITIONS;
		for (int i = 0; i < positions.length; i++) {
			if (up) {
				if (positions[i] > currentPosition
						+ RobotMap.kELEVATOR_PID_TOLERANCE
						&& candidate > positions[i]) {
					candidate = positions[i];
				}
			} else {
				if (positions[i] < currentPosition
						- RobotMap.kELEVATOR_PID_TOLERANCE
						&& candidate < positions[i]) {
					candidate = positions[i];
				}
			}
		}
		if (candidate > 9000 || candidate < -9000) {
			candidate = currentPosition;
		}
		return candidate;
	}

	protected double returnPIDInput() {
		// Return your input value for the PID loop
		// e.g. a sensor, like a potentiometer:
		// yourPot.getAverageVoltage() / kYourMaxVoltage;

		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=SOURCE
        return elevatorEncoder.pidGet();

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=SOURCE
	}

	protected void usePIDOutput(double output) {
		// Use output to drive your system, like a motor
		// e.g. yourMotor.set(output);
		if (output > 0) {
			if (limitUp.get()
					|| getRatchetDirection() != RatchetDirectionEnum.UP) {
				output = 0;
			}
		} else if (output < 0) {
			if (limitDown.get()
					|| getRatchetDirection() != RatchetDirectionEnum.DOWN) {
				output = 0;
			}
		}
		if (!turbo) {
			output = Math.max(output, RobotMap.kELEVATOR_MAX_SPEED_DOWN);
		} else {
			output = Math.max(output, RobotMap.kELEVATOR_TURBO_DOWN_SPEED);
		}
		output = Math.min(output, RobotMap.kELEVATOR_MAX_SPEED_UP);

		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=OUTPUT
        elevatorMotor.pidWrite(output);

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=OUTPUT
	}

	public void smartDashboardPush() {
		SmartDashboard.putNumber("Elevator_Height", 
				getElevatorCurrentPosition() * 10 / 45);
		SmartDashboard.putNumber("LB_Speed", getElevatorCurrentPosition());
		SmartDashboard.putBoolean("Top_Limit", isUpperLimitReached());
		SmartDashboard.putBoolean("Bottom_Limit", isLowerLimitReached());
		SmartDashboard.putBoolean("Ratchet_Position", limitRatchet.get());
	}

	public void printStuff() {
		System.out.println("Ratchet limit: " + limitRatchet.get()
				+ " Ratchet dir: " + getRatchetDirection());
	}
}
