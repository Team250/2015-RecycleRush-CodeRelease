// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc250.RecycleRush;

import org.usfirst.frc250.RecycleRush.Utilities;

import edu.wpi.first.wpilibj.*;
import edu.wpi.first.wpilibj.command.PIDSubsystem;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;

/**
 *
 */
public class SwerveModule extends PIDSubsystem {
	Encoder encoder;
	SpeedController angleMotor;
	SpeedController distanceMotor;
	public int motorInverted = 1;
	private double initialAngle = 0;

	public SwerveModule(Encoder encoder, SpeedController angleMotor,
			SpeedController distanceMotor,
			double initialAngle) {
		super("Drivetrain", 0.014, 0.001, 0.0011);

		this.encoder = encoder;
		this.angleMotor = angleMotor;
		this.distanceMotor = distanceMotor;
		this.initialAngle = initialAngle;

		setAbsoluteTolerance(10);
		getPIDController().setContinuous(false);
		LiveWindow.addActuator("Drivetrain", "PIDSubsystem Controller",
				getPIDController());

		this.encoder.setDistancePerPulse(1);
		enable();
		setSetpoint(0);
	}

	private double oldSpeed = 0;

	public double getAngle() {
		return Utilities.formatAngle((encoder.getDistance() % RobotMap.kPPR) * 360 / RobotMap.kPPR
				+ initialAngle);
	}
	
	public double getAngleWithInversion() {
		return Utilities.formatAngle(getAngle() + (motorInverted == -1 ? -360 : 0));  
	}

	public double getEncoderValue() {
		return encoder.getDistance();
	}
	
	public void resetEncoder() {
		encoder.reset();
	}

	public void setAngle(double targetAngle) {
		double encoderPosition = encoder.getDistance();
		double encoderPPR = RobotMap.kPPR;
		double currentAngle, angleDelta, positionDelta;
		targetAngle = Utilities.formatAngle(targetAngle);

		currentAngle = getAngle();
		angleDelta = Utilities.angleDifference(targetAngle, currentAngle);

		if (Math.abs(angleDelta) > 90) {
			positionDelta = (angleDelta - 180 * angleDelta
					/ Math.abs(angleDelta));
			if (onTarget())
				motorInverted = -1;
		} else {
			positionDelta = angleDelta;
			if (onTarget())
				motorInverted = 1;
		}

		setSetpoint(encoderPosition + positionDelta * encoderPPR / 360);
	}

	public void setToZero() {
		double angleDelta = getAngle();
		if (Math.abs(angleDelta) > 180)
			angleDelta += -360 * angleDelta / Math.abs(angleDelta);
		setSetpoint(encoder.getDistance() - (angleDelta * RobotMap.kPPR / 360));
	}

	public void drive(double speed) {
		speed *= motorInverted;
		speed = Utilities.motorRamp(RobotMap.kDRIVE_ACCELERATION_RAMPING,
				RobotMap.kDRIVE_DECCELERATION_RAMPING, speed, oldSpeed);
		distanceMotor.set(speed);
		oldSpeed = speed;
	}

	public void initDefaultCommand() {
	}

	protected double returnPIDInput() {
		return encoder.pidGet();
	}

	protected void usePIDOutput(double output) {
		angleMotor.pidWrite(output);
	}

	public void changePID(int magP, double maxChangeP, int magI,
			double maxChangeI, int magD, double maxChangeD) {
		getPIDController().setPID(
				magP * maxChangeP + getPIDController().getP(),
				magI * maxChangeI + getPIDController().getI(),
				magD * maxChangeD + getPIDController().getD());
	}

	public double getKp() {
		return getPIDController().getP();
	}

	public double getKi() {
		return getPIDController().getI();
	}

	public double getKd() {
		return getPIDController().getD();
	}

	public void setPID(double p, double i, double d) {
		getPIDController().setPID(p, i, d);
	}

	public double getSpeed() {
		return oldSpeed;
	}
}
